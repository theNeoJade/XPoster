/// <reference types="node" />
import { AxiosRequestConfig } from 'axios';
import { REPLY_CONTROL_OPTIONS } from './constants';
import { AndroidDevice, Extensions, Story, Thread, ThreadsUser } from './threads-types';
import { StrictUnion } from './types/utils';
export type ErrorResponse = {
    status: 'error';
    error_title: string;
};
export type GetUserProfileResponse = {
    data: {
        userData: {
            user: ThreadsUser;
        };
    };
    extensions: Extensions;
};
export type GetUserProfileThreadsResponse = {
    data: {
        mediaData?: {
            threads: Thread[];
        };
    };
    extensions: Extensions;
};
export type GetUserProfileThreadsPaginatedResponse = {
    status: 'ok';
    next_max_id?: string;
    medias: [];
    threads: Thread[];
};
export type GetUserProfileLoggedInResponse = {
    users: ThreadsUser[];
    status: 'ok';
};
export type GetUserProfileFollowPaginatedResponse = {
    status: 'ok';
    users: ThreadsUser[];
    big_list: boolean;
    page_size: number;
    next_max_id?: string;
    should_limit_list_of_followers: boolean;
};
export type GetThreadRepliesPaginatedResponse = {
    containing_thread: Thread;
    reply_threads: Thread[];
    subling_threads: Thread[];
    paging_tokens: {
        downward: string;
    };
    downwards_thread_will_continue: boolean;
    target_post_reply_placeholder: string;
    status: 'ok';
};
export type GetNotificationsOptions = {
    feed_type: string;
    mark_as_seen: boolean;
    timezone_offset: number;
    timezone_name: string;
    selected_filters?: ThreadsAPI.NotificationFilter;
    max_id?: string;
    pagination_first_record_timestamp?: number;
};
export interface GetNotificationsPagination {
    maxID?: string;
    firstRecordTimestamp?: number;
}
export type GetNotificationsPaginatedResponse = {
    counts: {
        [key: string]: any;
    };
    last_checked: number;
    new_stories: Story[];
    old_stories: Story[];
    continuation_token: number;
    subscription: any;
    is_last_page: boolean;
    next_max_id: string;
    auto_load_more_enabled: boolean;
    pagination_first_record_timestamp: number;
    filters: any[];
    status: 'ok';
};
export type GetRecommendedUsersPaginatedResponse = {
    users: ThreadsUser[];
    paging_token: string;
    has_more: boolean;
    status: 'ok';
};
export type GetUserProfileThreadResponse = {
    data: {
        data: {
            containing_thread: Thread;
            reply_threads?: Thread[];
        };
    };
    extensions: Extensions;
};
export type GetThreadLikersResponse = {
    data: {
        likers: {
            users: ThreadsUser[];
        };
    };
    extensions: Extensions;
};
export type GetTimelineResponse = {
    num_results: number;
    more_available: boolean;
    auto_load_more_enabled: boolean;
    is_direct_v2_enabled: boolean;
    next_max_id: string;
    view_state_version: string;
    client_feed_changelist_applied: boolean;
    request_id: string;
    pull_to_refresh_window_ms: number;
    preload_distance: number;
    status: string;
    pagination_source: string;
    hide_like_and_view_counts: number;
    is_shell_response: boolean;
    items: Thread[];
    feed_items_media_info: Array<any>;
};
export type InstagramImageUploadResponse = {
    upload_id: string;
    xsharing_nonces: {};
    status: 'ok';
};
export type FriendshipStatusResponse = {
    friendship_status: {
        following: boolean;
        followed_by: boolean;
        blocking: boolean;
        muting: boolean;
        is_private: boolean;
        incoming_request: boolean;
        outgoing_request: boolean;
        text_post_app_pre_following: boolean;
        is_bestie: boolean;
        is_restricted: boolean;
        is_feed_favorite: boolean;
        is_eligible_to_subscribe: boolean;
    };
    status: 'ok';
};
export declare const DEFAULT_DEVICE: AndroidDevice;
export declare namespace ThreadsAPI {
    type Options = {
        verbose?: boolean;
        token?: string;
        fbLSDToken?: string;
        noUpdateToken?: boolean;
        noUpdateLSD?: boolean;
        httpAgent?: AxiosRequestConfig['httpAgent'];
        httpsAgent?: AxiosRequestConfig['httpsAgent'];
        username?: string;
        password?: string;
        deviceID?: string;
        device?: AndroidDevice;
        userID?: string;
        locale?: string;
        maxRetries?: number;
    };
    type ExternalImage = {
        path: string;
    };
    type RawImage = {
        type: string;
        data: Buffer;
    };
    type Image = string | ExternalImage | RawImage;
    type ImageAttachment = {
        image: Image;
    };
    type SidecarAttachment = {
        sidecar: Image[];
    };
    type LinkAttachment = {
        url: string;
    };
    type PostAttachment = StrictUnion<ImageAttachment | SidecarAttachment | LinkAttachment>;
    type PostReplyControl = keyof typeof REPLY_CONTROL_OPTIONS;
    enum NotificationFilter {
        MENTIONS = "text_post_app_mentions",
        REPLIES = "text_post_app_replies",
        VERIFIED = "verified"
    }
    type PublishOptions = {
        text?: string;
        replyControl?: PostReplyControl;
        parentPostID?: string;
        quotedPostID?: string;
        attachment?: PostAttachment;
        /** @deprecated Use `attachment.url` instead. */
        url?: string;
        /** @deprecated Use `attachment.image` instead. */
        image?: Image;
    };
}
interface UserIDQuerier<T extends any> {
    (userID: string, options?: AxiosRequestConfig): Promise<T>;
    (username: string, userID: string, options?: AxiosRequestConfig): Promise<T>;
}
interface UserProfileQuerier<T extends any> {
    (userID: string, options?: AxiosRequestConfig): Promise<T>;
}
interface PaginationUserIDQuerier<T extends any> {
    (userID: string, maxID?: string, options?: AxiosRequestConfig): Promise<T>;
}
interface PaginationRepliesQuerier<T extends any> {
    (postID: string, maxID?: string, options?: AxiosRequestConfig): Promise<T>;
}
interface PaginationNotificationsQuerier<T extends any> {
    (filter?: ThreadsAPI.NotificationFilter, pagination?: GetNotificationsPagination, config?: AxiosRequestConfig): Promise<T>;
}
interface PaginationRecommendedQuerier<T extends any> {
    (maxID?: string, config?: AxiosRequestConfig): Promise<T>;
}
interface SearchQuerier<T extends any> {
    (query: string, count?: number, options?: AxiosRequestConfig): Promise<T>;
}
export type SearchUsersResponse = {
    num_results: number;
    users: ThreadsUser[];
    has_more: boolean;
    rank_token: string;
    status: 'ok';
};
export type PaginationAndSearchOptions = {
    maxID?: string;
    query?: string;
};
interface PaginationAndSearchUserIDQuerier<T extends any> {
    (userID: string, params?: PaginationAndSearchOptions, options?: AxiosRequestConfig): Promise<T>;
}
export declare class ThreadsAPI {
    verbose: boolean;
    token?: string;
    fbLSDToken: string;
    noUpdateToken: boolean;
    noUpdateLSD: boolean;
    httpAgent?: AxiosRequestConfig['httpAgent'];
    httpsAgent?: AxiosRequestConfig['httpsAgent'];
    username?: string;
    password?: string;
    deviceID: string;
    device: AndroidDevice;
    userID?: string;
    locale: string;
    maxRetries: number;
    constructor(options?: ThreadsAPI.Options);
    sign(payload: object | string): {
        ig_sig_key_version: number;
        signed_body: string;
    };
    syncLoginExperiments: () => Promise<import("axios").AxiosResponse<any, any>>;
    encryptPassword: (password: string) => Promise<{
        time: string;
        password: string;
    }>;
    login: () => Promise<{
        token: string;
        userID: string | undefined;
    }>;
    _getUnAuthenticatedHeaders: () => {
        'User-Agent': string;
        'Content-Type': string;
    };
    _getDefaultUserDataHeaders: (username?: string) => {
        Referer?: string | undefined;
        Host: string;
        Accept: string;
        'Accept-Language': string;
        'cache-control': string;
        Origin: string;
        Pragma: string;
        'Sec-Fetch-Site': string;
        'X-Asbd-id': string;
        'X-FB-Friendly-Name': string;
        'X-FB-Lsd': string;
        'X-Ig-App-Id': string;
        'User-Agent': string;
        'Content-Type': string;
    };
    _getAppHeaders: () => {
        Authorization?: string | undefined;
        'User-Agent': string;
        'Content-Type': string;
    };
    _getInstaHeaders: () => {
        'X-Ig-App-Locale'?: string | undefined;
        'X-Ig-Device-Locale'?: string | undefined;
        'X-Ig-Mapped-Locale'?: string | undefined;
        'Ig-U-Ds-User-Id'?: string | undefined;
        'Ig-Intended-User-Id'?: string | undefined;
        'X-Bloks-Is-Layout-Rtl': string;
        'X-Bloks-Version-Id': string;
        'X-Ig-Android-Id': string;
        'X-Ig-App-Id': string;
        'Accept-Language': string;
        Authorization?: string | undefined;
        'User-Agent': string;
        'Content-Type': string;
    };
    _getDefaultHeaders: (username?: string) => {
        referer?: string | undefined;
        authority: string;
        accept: string;
        'accept-language': string;
        'cache-control': string;
        origin: string;
        pragma: string;
        'Sec-Fetch-Site': string;
        'x-asbd-id': string;
        'x-fb-lsd': string;
        'x-ig-app-id': string;
        Authorization?: string | undefined;
        'User-Agent': string;
        'Content-Type': string;
    };
    _getCleanedProfileHTML: (url: string, username: string, options?: AxiosRequestConfig) => Promise<string>;
    getUserIDfromUsernameWithInstagram: (username: string, options?: AxiosRequestConfig) => Promise<string | undefined>;
    getUserIDfromUsername: (username: string, options?: AxiosRequestConfig) => Promise<string | undefined>;
    getCurrentUserID: (options?: AxiosRequestConfig) => Promise<string | undefined>;
    _requestQuery: <T extends unknown>(url: string, data: Record<string, string | undefined>, options?: AxiosRequestConfig) => Promise<import("axios").AxiosResponse<T, any>>;
    _requestUserDataQuery: <T extends unknown>(url: string, data: Record<string, string | undefined>, options?: AxiosRequestConfig) => Promise<import("axios").AxiosResponse<T, any>>;
    _destructureFromUserIDQuerier: (params: any) => {
        userID: string;
        options: AxiosRequestConfig<any> | undefined;
    };
    getUserProfile: UserIDQuerier<ThreadsUser>;
    getUserProfileLoggedIn: UserProfileQuerier<GetUserProfileLoggedInResponse>;
    getUserProfileThreads: UserIDQuerier<Thread[]>;
    getUserProfileThreadsLoggedIn: PaginationUserIDQuerier<GetUserProfileThreadsPaginatedResponse>;
    _getDefaultRepliesHeaders: (username?: string) => {
        Referer?: string | undefined;
        Host: string;
        Accept: string;
        'Accept-Language': string;
        'cache-control': string;
        Origin: string;
        Pragma: string;
        'Sec-Fetch-Site': string;
        'X-Asbd-id': string;
        'X-FB-Friendly-Name': string;
        'X-FB-Lsd': string;
        'X-Ig-App-Id': string;
        'User-Agent': string;
        'Content-Type': string;
    };
    _requestRepliesQuery: <T extends unknown>(url: string, data: Record<string, string | undefined>, options?: AxiosRequestConfig) => Promise<import("axios").AxiosResponse<T, any>>;
    getUserProfileReplies: UserIDQuerier<Thread[]>;
    getUserProfileRepliesLoggedIn: PaginationUserIDQuerier<GetUserProfileThreadsPaginatedResponse>;
    getUserFollowers: PaginationAndSearchUserIDQuerier<GetUserProfileFollowPaginatedResponse>;
    getUserFollowings: PaginationAndSearchUserIDQuerier<GetUserProfileFollowPaginatedResponse>;
    getPostIDfromThreadID: (threadID: string) => string;
    getPostIDfromURL: (postURL: string) => string;
    getThreads: (postID: string, options?: AxiosRequestConfig) => Promise<{
        containing_thread: Thread;
        reply_threads?: Thread[] | undefined;
    }>;
    getThreadsLoggedIn: PaginationRepliesQuerier<GetThreadRepliesPaginatedResponse>;
    getThreadLikers: (postID: string, options?: AxiosRequestConfig) => Promise<{
        users: ThreadsUser[];
    }>;
    getTimeline: (maxID?: string, options?: AxiosRequestConfig) => Promise<GetTimelineResponse>;
    _fetchAuthGetRequest: <T extends unknown>(url: string, options?: AxiosRequestConfig) => Promise<import("axios").AxiosResponse<T, any>>;
    _toggleAuthPostRequest: <T extends unknown>(url: string, data?: Record<string, string>, options?: AxiosRequestConfig) => Promise<import("axios").AxiosResponse<T, any>>;
    like: (postID: string, options?: AxiosRequestConfig) => Promise<{
        status: 'ok' | string;
    }>;
    unlike: (postID: string, options?: AxiosRequestConfig) => Promise<{
        status: 'ok' | string;
    }>;
    follow: (userID: string, options?: AxiosRequestConfig) => Promise<FriendshipStatusResponse>;
    unfollow: (userID: string, options?: AxiosRequestConfig) => Promise<FriendshipStatusResponse>;
    repost: (postID: string, options?: AxiosRequestConfig) => Promise<FriendshipStatusResponse>;
    unrepost: (originalPostID: string, options?: AxiosRequestConfig) => Promise<FriendshipStatusResponse>;
    mute: (muteOptions: {
        postID?: string;
        userID: string;
    }, options?: AxiosRequestConfig) => Promise<boolean>;
    unmute: (muteOptions: {
        postID?: string;
        userID: string;
    }, options?: AxiosRequestConfig) => Promise<boolean>;
    block: (userID: string, options?: AxiosRequestConfig) => Promise<boolean>;
    unblock: (userID: string, options?: AxiosRequestConfig) => Promise<boolean>;
    getNotifications: PaginationNotificationsQuerier<GetNotificationsPaginatedResponse>;
    setNotificationsSeen: (options?: AxiosRequestConfig) => Promise<boolean>;
    searchUsers: SearchQuerier<SearchUsersResponse>;
    getRecommendedUsers: PaginationRecommendedQuerier<GetRecommendedUsersPaginatedResponse>;
    getToken: () => Promise<string | undefined>;
    _timezoneOffset: number | undefined;
    _lastUploadID: number;
    _nextUploadID: () => string;
    _createUploadMetadata: (uploadID?: string) => {
        upload_id: string;
        source_type: string;
        timezone_offset: string;
        device: AndroidDevice;
    };
    publish: (rawOptions: ThreadsAPI.PublishOptions | string) => Promise<string | undefined>;
    delete: (postID: string, options?: AxiosRequestConfig) => Promise<boolean>;
    /**
     * @deprecated: use `publish` instead
     **/
    publishWithImage: (caption: string, imagePath: string) => Promise<string | undefined>;
    uploadImage: (image: ThreadsAPI.Image, uploadID?: string) => Promise<InstagramImageUploadResponse>;
}
/** @deprecated Use `ThreadsAPI.Options` instead. */
export type ThreadsAPIOptions = ThreadsAPI.Options;
/** @deprecated Use `ThreadsAPI.PostReplyControl` instead. */
export type ThreadsAPIPostReplyControl = ThreadsAPI.PostReplyControl;
/** @deprecated Use `ThreadsAPI.RawImage` or `ThreadsAPI.ExternalImage` instead. */
export type ThreadsAPIImage = ThreadsAPI.RawImage | ThreadsAPI.ExternalImage;
/** @deprecated Use `ThreadsAPI.PublishOptions` instead. */
export type ThreadsAPIPublishOptions = ThreadsAPI.PublishOptions;
export default ThreadsAPI;
